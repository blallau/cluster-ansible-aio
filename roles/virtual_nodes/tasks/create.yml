---
- import_tasks: input_precheck.yml
- import_tasks: host_precheck.yml
- import_tasks: defaults-get.yml
- import_tasks: lvm_storage.yml

- import_role:
    name: common
    tasks_from: ssh_key

- import_tasks: define_cluster_networks.yml
- import_tasks: define_cluster_nodes.yml

- name: "[KVM host] Copy cluster config for {{ item.name }} in {{ tmp_dir }}//{{ group }}/{{ item.name }}"
  blockinfile:
    path: "{{ tmp_dir }}/{{ group }}/{{ item.name }}/cluster_config"
    create: true
    block: |
        {{ item | to_nice_json(indent=2) }}
  with_items: "{{ cluster_nodes }}"
  tags: network

- import_tasks: prepare_os_image.yml

- name: "[KVM host] Copy Libvirt XML domain for {{ item.name }} in {{ tmp_dir }}/{{ group }}/{{ item.name }}"
  blockinfile:
    path: "{{ tmp_dir }}/{{ group }}/{{ item.name }}/domain.xml"
    create: true
    block: |
        {{ lookup('template', 'vm-template.xml.j2') }}
  with_items: "{{ cluster_nodes }}"

- name: Prepare CloudInit/Ignition config
  include_tasks: postconfig.yml
  loop: "{{ cluster_nodes }}"

- import_tasks: libvirt/setup_networks.yml
  when: networks | length > 0
  tags: network

- include_tasks: libvirt/create_disks.yml

- name: Libvirt setup VMs
  block:
    - name: Define VMs
      community.libvirt.virt:
        command: define
        xml: "{{ lookup('template', 'vm-template.xml.j2') }}"
      with_items: "{{ cluster_nodes }}"

    - name: Start a VMs
      community.libvirt.virt:
        name: "{{ item.fullname }}"
        state: running
      with_items: "{{ cluster_nodes }}"

      # Wait for network so we can get the IP to log in
      # Do this for all VMs, in case they already existed and IP has changed
    - name: Get IP address of VM
      become: true
      shell: >
        set -o pipefail ;
        virsh
        --connect {{ libvirt_url }}
        domifaddr
        --source arp
        {{ item.fullname }}
        | grep -v 'N/A'
        | grep -vw lo
        | grep ipv4
        | grep -Ei '([0-9a-z]{2}:){5}[0-9a-z]{2}'
        | head -1
        | awk '{ print $NF}'
        | awk -F "/" '{print $1}'
      register: result_get_ip
      until: result_get_ip.stdout
      retries: 30
      delay: 10
      changed_when: false
      args:
        executable: /bin/bash
      with_items: "{{ cluster_nodes }}"

    - name: Wait for VMs to listen on port 22
      wait_for:
        host: "{{ item.1.address }}"
        port: 22
        delay: 10
        timeout: 180
      with_subelements:
        - "{{ cluster_nodes }}"
        - interfaces
      when: item.1.address is defined and item.1.external is defined and item.1.external

    - name: "Detach {{ cloud_init_disk }} config drive disk"
      command: virsh detach-disk {{ item.fullname }} --target {{ cloud_init_disk }} --persistent --live
      with_items: "{{ cluster_nodes }}"
      when: item.os_type in ["debian", "centos"]
      ignore_errors: true

- name: Insert nodes into ssh_config
  become: true
  blockinfile:
    create: true
    block: "{{ lookup('template', 'ssh_config.j2') }}"
    path: "{{ ansible_env.HOME }}/.ssh/config"

- name: Create file {{ tmp_dir }}/{{ group }}/ssh_config
  blockinfile:
    create: true
    block: "{{ lookup('template', 'ssh_config.j2') }}"
    path: "{{ tmp_dir }}/{{ group }}/ssh_config"

- name: Add new nodes to created_nodes Ansible group
  add_host:
    name: "{{ item.1.address }}"
    instance_name: "{{ item.0.name }}.{{ dns_domain }}"
    ansible_distribution: "{{ item.0.os_type }}"
    ansible_user: "{{ item.0.os_type }}"
    groups: created_nodes
  with_subelements:
    - "{{ cluster_nodes }}"
    - interfaces
  when:
    - item.1.address is defined
    - item.1.external is defined
    - item.1.external | bool

- name: Create file {{ tmp_dir }}/{{ group }}/etc_hosts
  become: true
  blockinfile:
    create: true
    block: "{{ lookup('template', 'etc_hosts.j2') }}"
    path: "{{ tmp_dir }}/{{ group }}/ssh_config"

- name: Populate /etc/hosts file
  become: true
  blockinfile:
    create: true
    block: "{{ lookup('template', 'etc_hosts.j2') }}"
    path: "/etc/hosts"

# - import_tasks: docker/enable_dns_server.yml
#   when: dns_server_enabled | bool
#   tags: dns_server

- name: Create virtual BMC
  shell: >
    {{ result_vbmc_path.stdout }} add {{ item.name }}
    --libvirt-uri {{ libvirt_url }}
    --port {{ item.vbmc_port }}
    --username {{ vbmc_user | default('admin') }}
    --password {{ vbmc_password | default('password') }}
  args:
    executable: /bin/bash
  register: result_vbmc_create
  retries: 10
  delay: 2
  until: result_vbmc_create is succeeded
  when:
    - vbmc_port is defined and vbmc_port
    - vbmc is defined and vbmc|bool
  with_items: "{{ cluster_nodes }}"
  notify:
    - restart virtual bmc

- name: Start virtual BMC
  shell: "set -o pipefail && {{ result_vbmc_path.stdout }} start {{ item.name }}"
  args:
    executable: /bin/bash
  register: result_vbmc_start
  retries: 10
  delay: 2
  until: result_vbmc_start is succeeded
  changed_when: false
  when:
    - vbmc_port is defined and vbmc_port
    - vbmc is defined and vbmc|bool
  with_items: "{{ cluster_nodes }}"

- meta: flush_handlers
